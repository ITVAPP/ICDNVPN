name: Complete libv2ray.aar Analysis
on:
  workflow_dispatch:

jobs:
  analyze:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
    
    - name: Install analysis tools
      run: |
        echo "Installing JADX..."
        wget -q https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
        unzip -q jadx-1.4.7.zip -d jadx
        chmod +x jadx/bin/jadx
        echo "✓ JADX installed"
        
        echo "Installing CFR..."
        wget -q https://github.com/leibnitz27/cfr/releases/download/0.152/cfr-0.152.jar -O cfr.jar
        echo "✓ CFR installed"
        
        echo "Installing Procyon..."
        wget -q https://github.com/mstrobel/procyon/releases/download/v0.6.0/procyon-decompiler-0.6.0.jar -O procyon.jar
        echo "✓ Procyon installed"
    
    - name: Basic AAR Information
      run: |
        echo "================================================"
        echo "           AAR File Basic Information"
        echo "================================================"
        
        echo -e "\n📁 FILE INFO:"
        ls -lh android/app/libs/libv2ray.aar
        file android/app/libs/libv2ray.aar
        md5sum android/app/libs/libv2ray.aar
        
        mkdir -p /tmp/aar_analysis
        cp android/app/libs/libv2ray.aar /tmp/aar_analysis/
        cd /tmp/aar_analysis
        unzip -q libv2ray.aar
        
        echo -e "\n📦 AAR CONTENTS:"
        ls -la
        
        echo -e "\n🌳 FILE STRUCTURE:"
        tree -h 2>/dev/null || find . -type f | sort | while read f; do
          size=$(ls -lh "$f" | awk '{print $5}')
          echo "  $f ($size)"
        done
    
    - name: Extract and Prepare classes.jar
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "           Extracting classes.jar"
        echo "================================================"
        
        mkdir -p extracted_classes
        cd extracted_classes
        jar xf ../classes.jar
        
        echo -e "\n📋 ALL CLASSES:"
        find . -name "*.class" | sort | while read class; do
          size=$(ls -l "$class" | awk '{print $5}')
          echo "  $class (${size} bytes)"
        done
        
        echo -e "\n📦 PACKAGE STRUCTURE:"
        find . -name "*.class" | sed 's|^\./||' | sed 's|/[^/]*\.class$||' | sort | uniq | while read pkg; do
          count=$(find "./$pkg" -maxdepth 1 -name "*.class" 2>/dev/null | wc -l)
          echo "  📁 $pkg ($count classes)"
        done
    
    - name: Complete javap Analysis (All Access Levels)
      run: |
        cd /tmp/aar_analysis/extracted_classes
        
        echo "================================================"
        echo "    Complete javap Analysis (All Members)"
        echo "================================================"
        
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔍 CLASS: $class_name"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          echo -e "\n📊 CLASS INFO:"
          javap -cp . "$class_name" 2>/dev/null | head -5 || echo "Failed to analyze"
          
          echo -e "\n📌 ALL FIELDS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s+(public|protected|private|static|final).*;" | while read line; do
            echo "    $line"
          done || echo "    No fields found"
          
          echo -e "\n🔧 ALL METHODS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s+(public|protected|private|static|final|synchronized|native|abstract).*\(" | while read line; do
            echo "    $line"
          done || echo "    No methods found"
          
          native_methods=$(javap -p -cp . "$class_name" 2>/dev/null | grep "native" || true)
          if [ ! -z "$native_methods" ]; then
            echo -e "\n⚡ NATIVE METHODS:"
            echo "$native_methods" | while read line; do
              echo "    $line"
            done
          fi
        done
    
    - name: JADX Deep Decompilation
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "          JADX Decompilation"
        echo "================================================"
        
        $GITHUB_WORKSPACE/jadx/bin/jadx \
          --show-bad-code \
          --no-res \
          --deobf \
          --comments-level error \
          --log-level ERROR \
          -d decompiled_jadx \
          classes.jar 2>/dev/null || true
        
        echo -e "\n📝 DECOMPILED JAVA FILES:"
        find decompiled_jadx -name "*.java" 2>/dev/null | sort || echo "No files found"
        
        cat $(find decompiled_jadx -name "*.java" 2>/dev/null | sort) > all_decompiled_jadx.java || true
        
        echo -e "\n================================================"
        echo "          Complete Source Code (JADX)"
        echo "================================================"
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📄 ALL JADX DECOMPILED CODE"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        cat all_decompiled_jadx.java || echo "No source to display"
    
    - name: CFR Decompilation (Alternative)
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "          CFR Decompilation"
        echo "================================================"
        
        mkdir -p decompiled_cfr
        
        for class_file in $(find extracted_classes -name "*.class" | grep -E "libv2ray|go/Seq" | sort); do
          class_name=$(echo $class_file | sed 's|extracted_classes/||' | sed 's|\.class$||' | sed 's|/|.|g')
          output_file="decompiled_cfr/${class_name}.java"
          
          echo "Decompiling: $class_name"
          java -jar $GITHUB_WORKSPACE/cfr.jar "$class_file" > "$output_file" 2>/dev/null || true
        done
        
        echo -e "\n📝 CFR DECOMPILED FILES:"
        find decompiled_cfr -name "*.java" | sort
        
        cat $(find decompiled_cfr -name "*.java" | sort) > all_decompiled_cfr.java || true
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📄 ALL CFR DECOMPILED CODE"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        cat all_decompiled_cfr.java
    
    - name: Extract Critical Information
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "       Critical Information Extraction"
        echo "================================================"
        
        cat > method_summary.md << 'HEADER'
        # Method Summary for libv2ray.aar
        
        ## Available Classes and Methods
        
        HEADER
        
        for class_name in "libv2ray.Libv2ray" "libv2ray.CoreController" "libv2ray.CoreCallbackHandler" "go.Seq"; do
          echo -e "\n### $class_name\n" >> method_summary.md
          echo '```java' >> method_summary.md
          javap -public -cp extracted_classes "$class_name" 2>/dev/null | grep -E "public" | grep -v "class " >> method_summary.md || echo "Class not found" >> method_summary.md
          echo '```' >> method_summary.md
        done
        
        echo -e "\n📊 METHOD SUMMARY CREATED"
        cat method_summary.md
    
    - name: Search for V2Ray Specific Methods
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    V2Ray Specific Methods Search"
        echo "================================================"
        
        KEYWORDS=(
          "init" "start" "stop" "run"
          "config" "Config"
          "stats" "Stats"
          "protect" "Protect"
          "setup" "Setup"
          "prepare" "Prepare"
          "shutdown" "Shutdown"
          "version" "Version"
          "test" "Test"
          "check" "Check"
          "callback" "Callback"
          "emit" "Emit"
          "status" "Status"
          "V2" "v2"
          "ray" "Ray"
          "core" "Core"
          "controller" "Controller"
        )
        
        echo -e "\n🔍 SEARCHING FOR KEY METHODS:\n"
        
        for keyword in "${KEYWORDS[@]}"; do
          echo "━━━ Searching: $keyword ━━━"
          
          javap -p -cp extracted_classes $(find extracted_classes -name "*.class" | head -20 | xargs) 2>/dev/null | grep -i "$keyword" | head -5 || true
          
          if [ -d "decompiled_jadx" ]; then
            grep -r "$keyword" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | grep -v "//" | head -3 || true
          fi
          
          echo ""
        done
    
    - name: Generate Complete Kotlin Implementation
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    Generating Kotlin Implementation"
        echo "================================================"
        
        cat > V2RayVpnService_Complete.kt << 'KOTLIN'
        package com.example.cfvpn
        
        import android.app.NotificationChannel
        import android.app.NotificationManager
        import android.app.PendingIntent
        import android.app.Service
        import android.content.BroadcastReceiver
        import android.content.Context
        import android.content.Intent
        import android.content.IntentFilter
        import android.net.VpnService
        import android.os.*
        import android.util.Log
        import androidx.core.app.NotificationCompat
        import kotlinx.coroutines.*
        import java.io.File
        
        // Import based on AAR analysis
        import go.Seq
        import libv2ray.*
        
        /**
         * V2Ray VPN Service Implementation
         * Compatible with libv2ray.aar from 2dust/AndroidLibV2rayLite
         */
        class V2RayVpnService : VpnService() {
            
            companion object {
                private const val TAG = "V2RayVpnService"
                private const val NOTIFICATION_ID = 1
                private const val NOTIFICATION_CHANNEL_ID = "v2ray_vpn_channel"
            }
            
            private var mInterface: ParcelFileDescriptor? = null
            private var isRunning = false
            
            override fun onCreate() {
                super.onCreate()
                Log.d(TAG, "onCreate")
                
                try {
                    // Initialize Go runtime
                    Seq.setContext(applicationContext)
                    Log.d(TAG, "Go runtime initialized")
                    
                    // Initialize V2Ray environment
                    // Based on the AAR analysis, use appropriate method
                    // Example: Libv2ray.initV2Env(filesDir.absolutePath)
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Initialization failed", e)
                }
            }
            
            override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                Log.d(TAG, "onStartCommand")
                
                if (intent?.action == "STOP_VPN") {
                    stopVPN()
                    return START_NOT_STICKY
                }
                
                val config = intent?.getStringExtra("config")
                if (config.isNullOrEmpty()) {
                    Log.e(TAG, "No config provided")
                    stopSelf()
                    return START_NOT_STICKY
                }
                
                startForeground(NOTIFICATION_ID, createNotification())
                
                GlobalScope.launch(Dispatchers.IO) {
                    startVPN(config)
                }
                
                return START_STICKY
            }
            
            private suspend fun startVPN(config: String) = withContext(Dispatchers.IO) {
                try {
                    Log.d(TAG, "Starting VPN with config")
                    
                    // 1. Establish VPN tunnel
                    establishVPN()
                    
                    // 2. Start V2Ray core
                    // TODO: Call appropriate method from libv2ray
                    // Based on AAR analysis, this might be:
                    // - Libv2ray.startV2Ray(config)
                    // - CoreController.start(config)
                    // etc.
                    
                    isRunning = true
                    Log.i(TAG, "VPN started successfully")
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to start VPN", e)
                    stopSelf()
                }
            }
            
            private fun establishVPN() {
                Log.d(TAG, "Establishing VPN tunnel")
                
                val builder = Builder()
                builder.setSession("CFVPN")
                builder.setMtu(1500)
                builder.addAddress("10.0.0.2", 32)
                builder.addRoute("0.0.0.0", 0)
                builder.addDnsServer("8.8.8.8")
                builder.addDnsServer("8.8.4.4")
                
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    builder.addDisallowedApplication(packageName)
                }
                
                mInterface?.close()
                mInterface = builder.establish()
                
                Log.d(TAG, "VPN tunnel established: ${mInterface?.fd}")
            }
            
            private fun stopVPN() {
                Log.d(TAG, "Stopping VPN")
                
                isRunning = false
                
                // TODO: Stop V2Ray core
                // Based on AAR analysis
                
                mInterface?.close()
                mInterface = null
                
                stopForeground(true)
                stopSelf()
            }
            
            private fun createNotification(): android.app.Notification {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    val channel = NotificationChannel(
                        NOTIFICATION_CHANNEL_ID,
                        "VPN Service",
                        NotificationManager.IMPORTANCE_LOW
                    )
                    val nm = getSystemService(NotificationManager::class.java)
                    nm.createNotificationChannel(channel)
                }
                
                return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
                    .setContentTitle("CFVPN")
                    .setContentText("VPN is running")
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setPriority(NotificationCompat.PRIORITY_LOW)
                    .setOngoing(true)
                    .build()
            }
            
            override fun onDestroy() {
                super.onDestroy()
                Log.d(TAG, "onDestroy")
                stopVPN()
            }
        }
        KOTLIN
        
        echo "✅ Kotlin implementation generated"
        cat V2RayVpnService_Complete.kt
    
    - name: Create Final Report
      run: |
        cd /tmp/aar_analysis
        
        cat > FINAL_REPORT.md << 'EOF'
        # libv2ray.aar Analysis Complete Report
        
        ## Summary
        - Analysis completed successfully
        - All classes and methods extracted
        - Multiple decompilers used for accuracy
        - Kotlin implementation template generated
        
        ## Key Files Generated
        1. method_summary.md - All public methods
        2. V2RayVpnService_Complete.kt - Implementation template
        3. Decompiled source code in artifacts
        
        ## Next Steps
        1. Review the decompiled source code
        2. Update the Kotlin implementation based on actual methods found
        3. Test the implementation
        
        ## Important Notes
        - Check the method signatures carefully
        - Some methods might require specific parameters
        - Native methods need proper JNI setup
        
        EOF
        
        cp FINAL_REPORT.md $GITHUB_WORKSPACE/
        cp method_summary.md $GITHUB_WORKSPACE/
        cp V2RayVpnService_Complete.kt $GITHUB_WORKSPACE/
    
    - name: Upload all artifacts
      uses: actions/upload-artifact@v4
      with:
        name: complete-aar-analysis
        path: |
          FINAL_REPORT.md
          method_summary.md
          V2RayVpnService_Complete.kt
          /tmp/aar_analysis/all_decompiled_jadx.java
          /tmp/aar_analysis/all_decompiled_cfr.java
    
    - name: Display Summary
      run: |
        echo "================================================"
        echo "           ✅ ANALYSIS COMPLETE"
        echo "================================================"
        echo ""
        echo "📊 Results:"
        echo "  • All classes analyzed"
        echo "  • All methods documented"  
        echo "  • Source code decompiled"
        echo "  • Kotlin template created"
        echo ""
        echo "📥 Download artifacts to get:"
        echo "  • Complete source code"
        echo "  • Method documentation"
        echo "  • Implementation template"
        echo ""
        echo "================================================"
