name: Complete libv2ray.aar Analysis
on:
  workflow_dispatch:

jobs:
  analyze:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
    
    - name: Install analysis tools
      run: |
        echo "Installing JADX..."
        wget -q https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
        unzip -q jadx-1.4.7.zip -d jadx
        chmod +x jadx/bin/jadx
        echo "âœ“ JADX installed"
        
        echo "Installing CFR..."
        wget -q https://github.com/leibnitz27/cfr/releases/download/0.152/cfr-0.152.jar -O cfr.jar
        echo "âœ“ CFR installed"
        
        echo "Installing Procyon..."
        wget -q https://github.com/mstrobel/procyon/releases/download/v0.6.0/procyon-decompiler-0.6.0.jar -O procyon.jar
        echo "âœ“ Procyon installed"
    
    - name: Basic AAR Information
      run: |
        echo "================================================"
        echo "           AAR File Basic Information"
        echo "================================================"
        
        echo -e "\nðŸ“ FILE INFO:"
        ls -lh android/app/libs/libv2ray.aar
        file android/app/libs/libv2ray.aar
        md5sum android/app/libs/libv2ray.aar
        
        mkdir -p /tmp/aar_analysis
        cp android/app/libs/libv2ray.aar /tmp/aar_analysis/
        cd /tmp/aar_analysis
        unzip -q libv2ray.aar
        
        echo -e "\nðŸ“¦ AAR CONTENTS:"
        ls -la
        
        echo -e "\nðŸŒ³ FILE STRUCTURE:"
        tree -h 2>/dev/null || find . -type f | sort | while read f; do
          size=$(ls -lh "$f" | awk '{print $5}')
          echo "  $f ($size)"
        done
    
    - name: Check for Tun2Socks Integration
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "      Checking for Tun2Socks Integration"
        echo "================================================"
        
        # Check for native libraries related to tun2socks
        echo -e "\nðŸ” CHECKING NATIVE LIBRARIES FOR TUN2SOCKS:"
        if [ -d "jni" ]; then
          find jni -type f -name "*.so" | while read lib; do
            echo "Found native lib: $lib"
            # Check if the library contains tun2socks symbols
            strings "$lib" 2>/dev/null | grep -i -E "tun2socks|lwip|socks|tun" | head -20 || true
          done
        fi
        
        # Check AndroidManifest for tun2socks related permissions or services
        echo -e "\nðŸ“‹ CHECKING ANDROIDMANIFEST.XML:"
        if [ -f "AndroidManifest.xml" ]; then
          # Try to decode AndroidManifest
          cat AndroidManifest.xml | strings | grep -i -E "tun|socks|vpn" || echo "No tun2socks references in manifest"
        fi
        
        # Extract and check classes.jar for tun2socks
        echo -e "\nðŸ“¦ EXTRACTING CLASSES FOR TUN2SOCKS CHECK:"
        jar tf classes.jar | grep -i -E "tun2socks|tun|socks|lwip" || echo "No obvious tun2socks classes in jar"
    
    - name: Extract and Prepare classes.jar
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "           Extracting classes.jar"
        echo "================================================"
        
        mkdir -p extracted_classes
        cd extracted_classes
        jar xf ../classes.jar
        
        echo -e "\nðŸ“‹ ALL CLASSES:"
        find . -name "*.class" | sort | while read class; do
          size=$(ls -l "$class" | awk '{print $5}')
          echo "  $class (${size} bytes)"
        done
        
        echo -e "\nðŸ“¦ PACKAGE STRUCTURE:"
        find . -name "*.class" | sed 's|^\./||' | sed 's|/[^/]*\.class$||' | sort | uniq | while read pkg; do
          count=$(find "./$pkg" -maxdepth 1 -name "*.class" 2>/dev/null | wc -l)
          echo "  ðŸ“ $pkg ($count classes)"
        done
    
    - name: Deep Search for Tun2Socks Code
      run: |
        cd /tmp/aar_analysis/extracted_classes
        
        echo "================================================"
        echo "    Deep Search for Tun2Socks Related Code"
        echo "================================================"
        
        # Keywords specific to tun2socks implementation
        TUN2SOCKS_KEYWORDS=(
          "Tun2socks"
          "tun2socks"
          "TunInterface"
          "SocksProxy"
          "LwIP"
          "lwip"
          "PacketFlow"
          "TunDevice"
          "VpnTunnel"
          "TcpStack"
          "UdpStack"
          "IpStack"
          "PacketHandler"
          "TunWriter"
          "TunReader"
          "SocksClient"
          "Socks5"
          "ProxyHandler"
          "TunnelInterface"
          "NetworkStack"
        )
        
        echo -e "\nðŸ” SEARCHING FOR TUN2SOCKS SPECIFIC CLASSES AND METHODS:\n"
        
        for keyword in "${TUN2SOCKS_KEYWORDS[@]}"; do
          echo "â”â”â” Searching for: $keyword â”â”â”"
          
          # Search in class names
          find . -name "*.class" | grep -i "$keyword" 2>/dev/null && echo "  âœ“ Found in class names" || true
          
          # Search in class content using javap
          for class_file in $(find . -name "*.class" | head -50); do
            class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
            javap -p -cp . "$class_name" 2>/dev/null | grep -i "$keyword" | head -3 || true
          done
          
          echo ""
        done
        
        # Check for specific tun2socks method signatures
        echo -e "\nðŸ”§ CHECKING FOR TUN2SOCKS METHOD SIGNATURES:"
        
        SIGNATURE_PATTERNS=(
          "startTun2socks"
          "stopTun2socks"
          "writeTun"
          "readTun"
          "handlePacket"
          "processTunPacket"
          "socksConnect"
          "setupTunnel"
          "protectSocket"
          "getVpnInterface"
        )
        
        for pattern in "${SIGNATURE_PATTERNS[@]}"; do
          echo "Checking for method: $pattern"
          for class_file in $(find . -name "*.class"); do
            class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
            javap -p -cp . "$class_name" 2>/dev/null | grep -i "$pattern" && echo "  âœ“ Found in $class_name" || true
          done
        done
    
    - name: Complete javap Analysis (All Access Levels)
      run: |
        cd /tmp/aar_analysis/extracted_classes
        
        echo "================================================"
        echo "    Complete javap Analysis (All Members)"
        echo "================================================"
        
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ” CLASS: $class_name"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          echo -e "\nðŸ“Š CLASS INFO:"
          javap -cp . "$class_name" 2>/dev/null | head -5 || echo "Failed to analyze"
          
          echo -e "\nðŸ“Œ ALL FIELDS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s+(public|protected|private|static|final).*;" | while read line; do
            echo "    $line"
          done || echo "    No fields found"
          
          echo -e "\nðŸ”§ ALL METHODS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s+(public|protected|private|static|final|synchronized|native|abstract).*\(" | while read line; do
            echo "    $line"
          done || echo "    No methods found"
          
          native_methods=$(javap -p -cp . "$class_name" 2>/dev/null | grep "native" || true)
          if [ ! -z "$native_methods" ]; then
            echo -e "\nâš¡ NATIVE METHODS:"
            echo "$native_methods" | while read line; do
              echo "    $line"
            done
          fi
        done
    
    - name: JADX Deep Decompilation
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "          JADX Decompilation"
        echo "================================================"
        
        $GITHUB_WORKSPACE/jadx/bin/jadx \
          --show-bad-code \
          --no-res \
          --deobf \
          --comments-level error \
          --log-level ERROR \
          -d decompiled_jadx \
          classes.jar 2>/dev/null || true
        
        echo -e "\nðŸ“ DECOMPILED JAVA FILES:"
        find decompiled_jadx -name "*.java" 2>/dev/null | sort || echo "No files found"
        
        cat $(find decompiled_jadx -name "*.java" 2>/dev/null | sort) > all_decompiled_jadx.java || true
        
        echo -e "\n================================================"
        echo "          Complete Source Code (JADX)"
        echo "================================================"
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸ“„ ALL JADX DECOMPILED CODE"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        cat all_decompiled_jadx.java || echo "No source to display"
    
    - name: Search for Tun2Socks in Decompiled Code
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "   Searching Tun2Socks in Decompiled Code"
        echo "================================================"
        
        if [ -d "decompiled_jadx" ]; then
          echo -e "\nðŸ” TUN2SOCKS REFERENCES IN DECOMPILED CODE:\n"
          
          # Search for tun2socks patterns in decompiled Java files
          echo "â”â”â” Direct tun2socks references â”â”â”"
          grep -r -i "tun2socks" decompiled_jadx --include="*.java" 2>/dev/null | head -20 || echo "No direct tun2socks references"
          
          echo -e "\nâ”â”â” TUN interface references â”â”â”"
          grep -r -i -E "tun|tunnel" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | grep -v "//" | head -20 || echo "No TUN references"
          
          echo -e "\nâ”â”â” SOCKS proxy references â”â”â”"
          grep -r -i "socks" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | grep -v "//" | head -20 || echo "No SOCKS references"
          
          echo -e "\nâ”â”â” VPN tunnel handling â”â”â”"
          grep -r -E "vpn|VPN|Vpn" decompiled_jadx --include="*.java" 2>/dev/null | grep -E "tunnel|interface|packet" | head -20 || echo "No VPN tunnel references"
          
          echo -e "\nâ”â”â” Packet processing â”â”â”"
          grep -r -i -E "packet|datagram" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | head -20 || echo "No packet processing references"
        fi
    
    - name: CFR Decompilation (Alternative)
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "          CFR Decompilation"
        echo "================================================"
        
        mkdir -p decompiled_cfr
        
        for class_file in $(find extracted_classes -name "*.class" | grep -E "libv2ray|go/Seq" | sort); do
          class_name=$(echo $class_file | sed 's|extracted_classes/||' | sed 's|\.class$||' | sed 's|/|.|g')
          output_file="decompiled_cfr/${class_name}.java"
          
          echo "Decompiling: $class_name"
          java -jar $GITHUB_WORKSPACE/cfr.jar "$class_file" > "$output_file" 2>/dev/null || true
        done
        
        echo -e "\nðŸ“ CFR DECOMPILED FILES:"
        find decompiled_cfr -name "*.java" | sort
        
        cat $(find decompiled_cfr -name "*.java" | sort) > all_decompiled_cfr.java || true
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸ“„ ALL CFR DECOMPILED CODE"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        cat all_decompiled_cfr.java
    
    - name: Extract Critical Information
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "       Critical Information Extraction"
        echo "================================================"
        
        cat > method_summary.md << 'HEADER'
        # Method Summary for libv2ray.aar
        
        ## Available Classes and Methods
        
        HEADER
        
        for class_name in "libv2ray.Libv2ray" "libv2ray.CoreController" "libv2ray.CoreCallbackHandler" "go.Seq"; do
          echo -e "\n### $class_name\n" >> method_summary.md
          echo '```java' >> method_summary.md
          javap -public -cp extracted_classes "$class_name" 2>/dev/null | grep -E "public" | grep -v "class " >> method_summary.md || echo "Class not found" >> method_summary.md
          echo '```' >> method_summary.md
        done
        
        echo -e "\nðŸ“Š METHOD SUMMARY CREATED"
        cat method_summary.md
    
    - name: Search for V2Ray Specific Methods
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    V2Ray Specific Methods Search"
        echo "================================================"
        
        KEYWORDS=(
          "init" "start" "stop" "run"
          "config" "Config"
          "stats" "Stats"
          "protect" "Protect"
          "setup" "Setup"
          "prepare" "Prepare"
          "shutdown" "Shutdown"
          "version" "Version"
          "test" "Test"
          "check" "Check"
          "callback" "Callback"
          "emit" "Emit"
          "status" "Status"
          "V2" "v2"
          "ray" "Ray"
          "core" "Core"
          "controller" "Controller"
        )
        
        echo -e "\nðŸ” SEARCHING FOR KEY METHODS:\n"
        
        for keyword in "${KEYWORDS[@]}"; do
          echo "â”â”â” Searching: $keyword â”â”â”"
          
          javap -p -cp extracted_classes $(find extracted_classes -name "*.class" | head -20 | xargs) 2>/dev/null | grep -i "$keyword" | head -5 || true
          
          if [ -d "decompiled_jadx" ]; then
            grep -r "$keyword" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | grep -v "//" | head -3 || true
          fi
          
          echo ""
        done
    
    - name: Generate Tun2Socks Analysis Report
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    Generating Tun2Socks Analysis Report"
        echo "================================================"
        
        cat > tun2socks_analysis.md << 'EOF'
        # Tun2Socks Integration Analysis Report
        
        ## Analysis Summary
        This report analyzes whether libv2ray.aar contains tun2socks functionality.
        
        ## Key Findings
        
        ### 1. Native Libraries
        EOF
        
        # Add native library findings
        echo -e "\n#### Native Libraries Found:" >> tun2socks_analysis.md
        if [ -d "jni" ]; then
          find jni -name "*.so" -exec basename {} \; >> tun2socks_analysis.md 2>/dev/null || echo "No native libraries found" >> tun2socks_analysis.md
        else
          echo "No JNI directory found" >> tun2socks_analysis.md
        fi
        
        echo -e "\n### 2. Tun2Socks Related Classes" >> tun2socks_analysis.md
        echo '```' >> tun2socks_analysis.md
        find extracted_classes -name "*.class" | xargs -I {} basename {} .class | grep -i -E "tun|socks|tunnel|vpn" >> tun2socks_analysis.md 2>/dev/null || echo "No tun2socks related classes found" >> tun2socks_analysis.md
        echo '```' >> tun2socks_analysis.md
        
        echo -e "\n### 3. Tun2Socks Methods Found" >> tun2socks_analysis.md
        echo '```' >> tun2socks_analysis.md
        # Search for tun2socks methods in all classes
        for class_file in $(find extracted_classes -name "*.class"); do
          class_name=$(echo $class_file | sed 's|extracted_classes/||' | sed 's|\.class$||' | sed 's|/|.|g')
          javap -p -cp extracted_classes "$class_name" 2>/dev/null | grep -i -E "tun|socks|tunnel|packet|vpn" | grep -E "\(" >> tun2socks_analysis.md 2>/dev/null || true
        done
        echo '```' >> tun2socks_analysis.md
        
        echo -e "\n### 4. Integration Status" >> tun2socks_analysis.md
        echo -e "\n- [ ] Contains standalone tun2socks implementation" >> tun2socks_analysis.md
        echo "- [ ] Contains tun2socks JNI bindings" >> tun2socks_analysis.md
        echo "- [ ] Contains packet handling interfaces" >> tun2socks_analysis.md
        echo "- [ ] Contains SOCKS proxy client" >> tun2socks_analysis.md
        echo -e "\n## Conclusion" >> tun2socks_analysis.md
        echo "Based on the analysis, determine if libv2ray.aar includes tun2socks functionality or if it needs to be integrated separately." >> tun2socks_analysis.md
        
        cat tun2socks_analysis.md
    
    - name: Generate Complete Kotlin Implementation
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    Generating Kotlin Implementation"
        echo "================================================"
        
        cat > V2RayVpnService_Complete.kt << 'KOTLIN'
        package com.example.cfvpn
        
        import android.app.NotificationChannel
        import android.app.NotificationManager
        import android.app.PendingIntent
        import android.app.Service
        import android.content.BroadcastReceiver
        import android.content.Context
        import android.content.Intent
        import android.content.IntentFilter
        import android.net.VpnService
        import android.os.*
        import android.util.Log
        import androidx.core.app.NotificationCompat
        import kotlinx.coroutines.*
        import java.io.File
        
        // Import based on AAR analysis
        import go.Seq
        import libv2ray.*
        
        /**
         * V2Ray VPN Service Implementation
         * Compatible with libv2ray.aar from 2dust/AndroidLibV2rayLite
         */
        class V2RayVpnService : VpnService() {
            
            companion object {
                private const val TAG = "V2RayVpnService"
                private const val NOTIFICATION_ID = 1
                private const val NOTIFICATION_CHANNEL_ID = "v2ray_vpn_channel"
            }
            
            private var mInterface: ParcelFileDescriptor? = null
            private var isRunning = false
            
            override fun onCreate() {
                super.onCreate()
                Log.d(TAG, "onCreate")
                
                try {
                    // Initialize Go runtime
                    Seq.setContext(applicationContext)
                    Log.d(TAG, "Go runtime initialized")
                    
                    // Initialize V2Ray environment
                    // Based on the AAR analysis, use appropriate method
                    // Example: Libv2ray.initV2Env(filesDir.absolutePath)
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Initialization failed", e)
                }
            }
            
            override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                Log.d(TAG, "onStartCommand")
                
                if (intent?.action == "STOP_VPN") {
                    stopVPN()
                    return START_NOT_STICKY
                }
                
                val config = intent?.getStringExtra("config")
                if (config.isNullOrEmpty()) {
                    Log.e(TAG, "No config provided")
                    stopSelf()
                    return START_NOT_STICKY
                }
                
                startForeground(NOTIFICATION_ID, createNotification())
                
                GlobalScope.launch(Dispatchers.IO) {
                    startVPN(config)
                }
                
                return START_STICKY
            }
            
            private suspend fun startVPN(config: String) = withContext(Dispatchers.IO) {
                try {
                    Log.d(TAG, "Starting VPN with config")
                    
                    // 1. Establish VPN tunnel
                    establishVPN()
                    
                    // 2. Start V2Ray core
                    // TODO: Call appropriate method from libv2ray
                    // Based on AAR analysis, this might be:
                    // - Libv2ray.startV2Ray(config)
                    // - CoreController.start(config)
                    // etc.
                    
                    isRunning = true
                    Log.i(TAG, "VPN started successfully")
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to start VPN", e)
                    stopSelf()
                }
            }
            
            private fun establishVPN() {
                Log.d(TAG, "Establishing VPN tunnel")
                
                val builder = Builder()
                builder.setSession("CFVPN")
                builder.setMtu(1500)
                builder.addAddress("10.0.0.2", 32)
                builder.addRoute("0.0.0.0", 0)
                builder.addDnsServer("8.8.8.8")
                builder.addDnsServer("8.8.4.4")
                
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    builder.addDisallowedApplication(packageName)
                }
                
                mInterface?.close()
                mInterface = builder.establish()
                
                Log.d(TAG, "VPN tunnel established: ${mInterface?.fd}")
            }
            
            private fun stopVPN() {
                Log.d(TAG, "Stopping VPN")
                
                isRunning = false
                
                // TODO: Stop V2Ray core
                // Based on AAR analysis
                
                mInterface?.close()
                mInterface = null
                
                stopForeground(true)
                stopSelf()
            }
            
            private fun createNotification(): android.app.Notification {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    val channel = NotificationChannel(
                        NOTIFICATION_CHANNEL_ID,
                        "VPN Service",
                        NotificationManager.IMPORTANCE_LOW
                    )
                    val nm = getSystemService(NotificationManager::class.java)
                    nm.createNotificationChannel(channel)
                }
                
                return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
                    .setContentTitle("CFVPN")
                    .setContentText("VPN is running")
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setPriority(NotificationCompat.PRIORITY_LOW)
                    .setOngoing(true)
                    .build()
            }
            
            override fun onDestroy() {
                super.onDestroy()
                Log.d(TAG, "onDestroy")
                stopVPN()
            }
        }
        KOTLIN
        
        echo "âœ… Kotlin implementation generated"
        cat V2RayVpnService_Complete.kt
    
    - name: Create Final Report
      run: |
        cd /tmp/aar_analysis
        
        cat > FINAL_REPORT.md << 'EOF'
        # libv2ray.aar Analysis Complete Report
        
        ## Summary
        - Analysis completed successfully
        - All classes and methods extracted
        - Multiple decompilers used for accuracy
        - Tun2socks integration checked
        - Kotlin implementation template generated
        
        ## Tun2Socks Integration Status
        The workflow has checked for the presence of tun2socks functionality within libv2ray.aar.
        See tun2socks_analysis.md for detailed findings.
        
        ## Key Files Generated
        1. method_summary.md - All public methods
        2. tun2socks_analysis.md - Tun2socks integration analysis
        3. V2RayVpnService_Complete.kt - Implementation template
        4. Decompiled source code in artifacts
        
        ## Next Steps
        1. Review the tun2socks analysis to determine if additional integration is needed
        2. Review the decompiled source code
        3. Update the Kotlin implementation based on actual methods found
        4. If tun2socks is not included, consider integrating it separately
        5. Test the implementation
        
        ## Important Notes
        - Check the method signatures carefully
        - Some methods might require specific parameters
        - Native methods need proper JNI setup
        - If tun2socks is not included, you may need to add it as a separate dependency
        
        EOF
        
        cp FINAL_REPORT.md $GITHUB_WORKSPACE/
        cp method_summary.md $GITHUB_WORKSPACE/
        cp tun2socks_analysis.md $GITHUB_WORKSPACE/
        cp V2RayVpnService_Complete.kt $GITHUB_WORKSPACE/
    
    - name: Upload all artifacts
      uses: actions/upload-artifact@v4
      with:
        name: complete-aar-analysis
        path: |
          FINAL_REPORT.md
          method_summary.md
          tun2socks_analysis.md
          V2RayVpnService_Complete.kt
          /tmp/aar_analysis/all_decompiled_jadx.java
          /tmp/aar_analysis/all_decompiled_cfr.java
    
    - name: Display Summary
      run: |
        echo "================================================"
        echo "           âœ… ANALYSIS COMPLETE"
        echo "================================================"
        echo ""
        echo "ðŸ“Š Results:"
        echo "  â€¢ All classes analyzed"
        echo "  â€¢ All methods documented"
        echo "  â€¢ Tun2socks integration checked"
        echo "  â€¢ Source code decompiled"
        echo "  â€¢ Kotlin template created"
        echo ""
        echo "ðŸ” Tun2Socks Status:"
        if grep -q "tun2socks\|Tun2socks\|TUN2SOCKS" /tmp/aar_analysis/tun2socks_analysis.md 2>/dev/null; then
          echo "  â€¢ Tun2socks references found - check report for details"
        else
          echo "  â€¢ No obvious tun2socks integration detected"
          echo "  â€¢ May need separate tun2socks integration"
        fi
        echo ""
        echo "ðŸ“¥ Download artifacts to get:"
        echo "  â€¢ Complete source code"
        echo "  â€¢ Method documentation"
        echo "  â€¢ Tun2socks analysis report"
        echo "  â€¢ Implementation template"
        echo ""
        echo "================================================"
