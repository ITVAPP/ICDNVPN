name: Complete libv2ray.aar Analysis
on:
  workflow_dispatch:

jobs:
  analyze:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
    
    - name: Install analysis tools
      run: |
        # 安装 jadx (最新版本)
        wget https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
        unzip jadx-1.4.7.zip -d jadx
        chmod +x jadx/bin/jadx
        
        # 安装 dex2jar
        wget https://github.com/pxb1988/dex2jar/releases/download/v2.4/dex-tools-v2.4.zip
        unzip dex-tools-v2.4.zip
        chmod +x dex-tools-v2.4/*.sh
        
        # 安装 jd-cli (Java Decompiler命令行版)
        wget https://github.com/intoolswetrust/jd-cli/releases/download/jd-cli-1.2.1/jd-cli-1.2.1-dist.zip
        unzip jd-cli-1.2.1-dist.zip
        chmod +x jd-cli
    
    - name: Basic AAR Information
      run: |
        echo "================================================"
        echo "           AAR File Basic Information"
        echo "================================================"
        
        # 文件信息
        echo -e "\n[FILE INFO]"
        ls -lh android/app/libs/libv2ray.aar
        file android/app/libs/libv2ray.aar
        md5sum android/app/libs/libv2ray.aar
        
        # 解压 AAR
        mkdir -p /tmp/aar_analysis
        cp android/app/libs/libv2ray.aar /tmp/aar_analysis/
        cd /tmp/aar_analysis
        unzip -q libv2ray.aar
        
        echo -e "\n[AAR CONTENTS]"
        ls -la
        
        echo -e "\n[FILE STRUCTURE]"
        find . -type f | sort | while read f; do
          size=$(ls -lh "$f" | awk '{print $5}')
          echo "$f ($size)"
        done
    
    - name: Complete classes.jar Analysis with javap
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "         Complete javap Analysis"
        echo "================================================"
        
        # 解压 classes.jar
        jar xf classes.jar
        
        echo -e "\n[ALL CLASSES IN JAR]"
        find . -name "*.class" | sort | while read class; do
          echo "  - $class"
        done
        
        echo -e "\n[PACKAGE STRUCTURE]"
        find . -name "*.class" | sed 's|^\./||' | sed 's|/[^/]*\.class$||' | sort | uniq
        
        echo -e "\n================================================"
        echo "         Detailed Class Analysis"
        echo "================================================"
        
        # 分析每个类（包括私有成员）
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          echo -e "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "CLASS: $class_name"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          # 完整分析（包括私有成员）
          echo -e "\n[COMPLETE STRUCTURE]"
          javap -v -p -s -cp . "$class_name" 2>/dev/null || echo "Failed to analyze"
          
          # 只显示签名
          echo -e "\n[METHOD SIGNATURES ONLY]"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s*(public|protected|private|static|final)" || true
        done
    
    - name: JADX Deep Decompilation
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "          JADX Deep Decompilation"
        echo "================================================"
        
        # 使用 jadx 完全反编译（包括资源）
        $GITHUB_WORKSPACE/jadx/bin/jadx \
          --show-bad-code \
          --no-res \
          --no-debug-info \
          --deobf \
          -d decompiled_jadx \
          classes.jar
        
        echo -e "\n[DECOMPILED FILES]"
        find decompiled_jadx -name "*.java" | sort
        
        echo -e "\n================================================"
        echo "          Complete Source Code"
        echo "================================================"
        
        # 显示所有Java源文件
        for java_file in $(find decompiled_jadx -name "*.java" | sort); do
          echo -e "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "FILE: $java_file"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          cat "$java_file"
        done
    
    - name: JD-CLI Decompilation (Alternative)
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "       JD-CLI Alternative Decompilation"
        echo "================================================"
        
        # 使用 JD-CLI 作为备选反编译器
        $GITHUB_WORKSPACE/jd-cli -od decompiled_jd -g ALL classes.jar || true
        
        if [ -d "decompiled_jd" ]; then
          echo -e "\n[JD DECOMPILED FILES]"
          find decompiled_jd -name "*.java" | sort
          
          # 比较两个反编译器的结果
          echo -e "\n[COMPARING DECOMPILERS]"
          for java_file in $(find decompiled_jd -name "*.java" | sort); do
            filename=$(basename "$java_file")
            echo -e "\n--- $filename (JD-CLI version) ---"
            cat "$java_file"
          done
        fi
    
    - name: Extract ALL Methods and Fields
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "    Complete Methods and Fields Extraction"
        echo "================================================"
        
        # 创建方法和字段的完整列表
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          
          echo -e "\n[CLASS: $class_name]"
          
          # 提取所有字段
          echo "  FIELDS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s*(public|protected|private|static|final).*;" | sed 's/^/    /' || true
          
          # 提取所有方法
          echo "  METHODS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s*(public|protected|private|static|final|synchronized|native|abstract).*\(" | sed 's/^/    /' || true
          
          # 提取构造函数
          echo "  CONSTRUCTORS:"
          javap -p -cp . "$class_name" 2>/dev/null | grep -E "^\s*(public|protected|private).*$class_name\(" | sed 's/^/    /' || true
        done
    
    - name: Search for Interface Implementations
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "      Interface Implementation Analysis"
        echo "================================================"
        
        # 查找所有接口
        echo -e "\n[INTERFACES]"
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          javap -cp . "$class_name" 2>/dev/null | grep "interface" | head -1 || true
        done
        
        # 查找实现关系
        echo -e "\n[IMPLEMENTATIONS]"
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          javap -cp . "$class_name" 2>/dev/null | grep -E "(implements|extends)" | head -1 || true
        done
    
    - name: Native Methods and JNI Analysis
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "        Native Methods & JNI Analysis"
        echo "================================================"
        
        # 查找所有 native 方法
        echo -e "\n[NATIVE METHODS]"
        for class_file in $(find . -name "*.class" | sort); do
          class_name=$(echo $class_file | sed 's|^\./||' | sed 's|\.class$||' | sed 's|/|.|g')
          native_methods=$(javap -p -cp . "$class_name" 2>/dev/null | grep "native" || true)
          if [ ! -z "$native_methods" ]; then
            echo -e "\nClass: $class_name"
            echo "$native_methods"
          fi
        done
        
        # 分析 JNI 库
        echo -e "\n[JNI LIBRARIES]"
        if [ -d "jni" ]; then
          for arch in armeabi-v7a arm64-v8a x86 x86_64; do
            if [ -d "jni/$arch" ]; then
              echo -e "\nArchitecture: $arch"
              ls -lh "jni/$arch/"
              
              # 检查符号（如果有 nm 工具）
              if command -v nm &> /dev/null; then
                for so_file in jni/$arch/*.so; do
                  echo "  Symbols in $(basename $so_file):"
                  nm -D "$so_file" 2>/dev/null | grep "Java_" | head -10 || true
                done
              fi
            fi
          done
        fi
    
    - name: Critical V2Ray Methods Search
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "       Critical V2Ray Methods Search"
        echo "================================================"
        
        # 关键方法列表
        METHODS=(
          "initV2Env" "initializeV2Ray" "init"
          "startV2Ray" "start" "run" "runLoop"
          "stopV2Ray" "stop" "shutdown"
          "testConfig" "checkConfig" "validateConfig"
          "queryStats" "getStats" "statistics"
          "protect" "onProtect"
          "setup" "onSetup" "prepare"
          "NewV2RayPoint" "V2RayPoint"
          "setConfig" "updateConfig"
          "onEmitStatus" "emitStatus"
          "CoreController" "Controller"
          "CallbackHandler" "Callback"
          "getVersion" "checkVersion"
        )
        
        echo -e "\n[METHOD SEARCH RESULTS]"
        for method in "${METHODS[@]}"; do
          echo -e "\nSearching for: $method"
          echo "-------------------"
          
          # 在类文件中搜索
          grep -r "$method" . --include="*.class" 2>/dev/null | head -3 || true
          
          # 在反编译的Java中搜索
          if [ -d "decompiled_jadx" ]; then
            grep -r "$method" decompiled_jadx --include="*.java" 2>/dev/null | grep -v "import" | head -3 || true
          fi
        done
    
    - name: Generate Complete Kotlin Template
      run: |
        cd /tmp/aar_analysis
        
        echo "================================================"
        echo "     Generated Kotlin Implementation Guide"
        echo "================================================"
        
        # 基于发现的方法生成 Kotlin 模板
        cat << 'EOF' > kotlin_template.kt
        // Auto-generated template based on AAR analysis
        package com.example.cfvpn
        
        import android.app.Service
        import android.content.Intent
        import android.net.VpnService
        import android.os.ParcelFileDescriptor
        import android.util.Log
        
        // Import discovered packages
        import go.Seq
        import libv2ray.*
        
        /**
         * V2Ray VPN Service Implementation
         * Based on libv2ray.aar analysis
         */
        class V2RayVpnService : VpnService() {
            
            companion object {
                private const val TAG = "V2RayVpnService"
            }
            
            private var vpnInterface: ParcelFileDescriptor? = null
            
            override fun onCreate() {
                super.onCreate()
                
                // Initialize Go runtime (if go.Seq exists)
                try {
                    Seq.setContext(applicationContext)
                    Log.d(TAG, "Go runtime initialized")
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to initialize Go runtime", e)
                }
                
                // TODO: Add initialization based on discovered methods
                // Example: Libv2ray.initV2Env(filesDir.absolutePath)
            }
            
            override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                val config = intent?.getStringExtra("config") ?: return START_NOT_STICKY
                
                // TODO: Implement based on discovered methods
                
                return START_STICKY
            }
            
            private fun establishVpn(): ParcelFileDescriptor? {
                val builder = Builder()
                builder.setSession("CFVPN")
                builder.setMtu(1500)
                builder.addAddress("10.0.0.2", 32)
                builder.addRoute("0.0.0.0", 0)
                builder.addDnsServer("8.8.8.8")
                return builder.establish()
            }
            
            override fun onDestroy() {
                super.onDestroy()
                // TODO: Cleanup based on discovered methods
                vpnInterface?.close()
            }
        }
        EOF
        
        echo "Template saved to kotlin_template.kt"
        cat kotlin_template.kt
    
    - name: Create Final Analysis Report
      run: |
        cd /tmp/aar_analysis
        
        # 生成 Markdown 报告
        cat << 'EOF' > analysis_report.md
        # libv2ray.aar Complete Analysis Report
        
        ## Summary
        - Analysis Date: $(date)
        - AAR Size: $(ls -lh $GITHUB_WORKSPACE/android/app/libs/libv2ray.aar | awk '{print $5}')
        - Classes Found: $(find . -name "*.class" | wc -l)
        - Native Libraries: $(find jni -name "*.so" 2>/dev/null | wc -l || echo "0")
        
        ## Key Findings
        
        ### Available Packages
        $(find . -name "*.class" | sed 's|^\./||' | sed 's|/[^/]*\.class$||' | sort | uniq | sed 's/^/- /')
        
        ### Public Methods Found
        (See detailed analysis in logs)
        
        ## Recommendations
        Based on the analysis, update your Kotlin code to use the discovered interfaces.
        
        EOF
        
        cp analysis_report.md $GITHUB_WORKSPACE/
        cp kotlin_template.kt $GITHUB_WORKSPACE/ || true
    
    - name: Upload all analysis artifacts
      uses: actions/upload-artifact@v4
      with:
        name: complete-aar-analysis
        path: |
          analysis_report.md
          kotlin_template.kt
          /tmp/aar_analysis/decompiled_jadx/**/*.java
          /tmp/aar_analysis/decompiled_jd/**/*.java
    
    - name: Final Summary
      run: |
        echo "================================================"
        echo "           ANALYSIS COMPLETE"
        echo "================================================"
        echo ""
        echo "✅ All classes analyzed"
        echo "✅ All methods extracted"
        echo "✅ All fields documented"
        echo "✅ Native methods identified"
        echo "✅ Decompiled source available"
        echo "✅ Kotlin template generated"
        echo ""
        echo "Check the artifacts for:"
        echo "1. Complete decompiled source code"
        echo "2. Analysis report"
        echo "3. Kotlin implementation template"
